//
//  MainWorker.swift
//  CleanWeahter
//
//  Created by Seokho on 2020/10/26.
//  Copyright (c) 2020 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//
import CoreLocation
import UIKit

import RxSwift

protocol MainWorkerNetworking {
	func fetchData(request: Main.FetchWeather.Request, completion: @escaping (Result<Weather, Error>) -> Void)
}
class MainWorker: MainWorkerNetworking {
	
	let mainRepository: MainRepository
	var locaitonManager: LocationManager?
	private var disposeBag: DisposeBag = DisposeBag()
	
	init(mainRepository: MainRepository = MainRepository()) {
		self.mainRepository = mainRepository
	}
	
	func fetchData(request: Main.FetchWeather.Request, completion: @escaping (Result<Weather, Error>) -> Void) {

		self.locaitonManager = LocationManager(notPermissionMessage: { [weak self] isPermission in
			guard let self = self else { return }
			
			if isPermission {
				self.locaitonManager?.requestLocation(location: { result in
                    switch result {
                    case .success(let location):
                        self.requetWeather(location: location, unit: request.unit, completion: completion)
                    case .failure:
                        let location = CLLocation(latitude: 37.5642135, longitude: 127.0016985)
                        self.requetWeather(location: location, unit: request.unit, completion: completion)
                    }
				})
			} else {
				let location = CLLocation(latitude: 37.5642135, longitude: 127.0016985)
				self.requetWeather(location: location, unit: request.unit, completion: completion)
			}
			
		})
	}
	
	func requetWeather(location: CLLocation, unit: String, completion: @escaping (Result<Weather, Error>) -> Void) {
		
		self.mainRepository.network.request(WeatherAPI.forecast(location: location, unit: unit))
		   .map { try JSONDecoder().decode(Weather.self, from: $0.data) }
		   .subscribe { weather in
			   completion(.success(weather))
		   } onError: { error in
			   completion(.failure(error))
		   }.disposed(by: self.disposeBag)
	}
	

}
